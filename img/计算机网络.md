# 计算机网络

![计算机网络知识地图](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB5WTuAFewMAAQkN4m6j9E321.png "计算机网络知识地图")



# 计算机领域的7种基础知识

1. **计算机组成原理**

   讲述的是计算机是什么？计算是怎么回事？硬件如何为应用提供计算？

2. **操作系统**

   ​	操作系统对于我们最大的实践意义是：如何合理规划应用的生命周期以及资源使用，比如如何处理高并发、如何提升系统的稳定性、如何节约硬件成本等。具体来说学好操作系统，在写应用、服务的时候，就可以对 CPU、磁盘、内存、网络等资源进行合理规划，达到较高的利用率。所以，每个应用开发者都需要重视这块知识。

3. **计算机网络**

   ​	讲的是应用之间如何进行通信、如何设计应用之间的契约，形成稳定、高效、规范的协作关系（也就是协议）；并通过优化网络的性能，最终节省成本或者让用户满意。比如你：

   - 为了让页面秒开、服务秒回，做出的所有的努力；

   - 为了优化网络传输细节，去调整 TCP 的滑动窗口；

   - 为了提升网络的吞吐量、减少延迟，去开启多路复用能力；

   - 为了避免 Downtime，去调整网络的连接池和线程数；

   - 为了开发某个应用，尝试去理解一些应用层协议，比如 SSH、RTCP、HTTP2.0， MQTT 等；

   - 为了做好日常开发，去理解一些基本概念，比如 DNS、CDN、NAT、IPv4/6 等

4. **算法和数据结构**

   ​	算法和数据结构是两种科学，但是又彼此相互关联。算法是一个计算过程，数据结构是数据的组织方式。无论是计算过程还是数据的组织，我们都需要一个优化的方式——这就是算法和数据结构讨论的问题。

   ​	一个问题，有很多种解决方案，那么你想不想知道最优解是什么？虽然在给定资源的条件下，只要资源没有耗尽，问题得到解决，让用户满意，就不需要最优方案——比如最低的延迟、最少的计算时间、最大的空间利用率。

5. **图形学**

   ​	图形学讨论的是应用和人之间的交互桥梁。有同学会问，那我不开发带图形的应用，只开发后端服务，还需要学习图形学吗？

   ​	我只能说，如果你对未来的世界，比如电影、VR、AR、虚拟世界、自动驾驶等充满好奇和期待， 可以尝试学一下这门课。特别是想学 AI 的同学，要知道，深度学习把数据看作图片，让 AI 下棋，你以为它在思考，其实它只是从很多图形中找到概率特征。	

6. **编程技巧**

   ​	编程不是算法，编程是语言。语言研究的是怎么表达得更清楚。中国自古有信、达、雅的说法，编程也是这样。算法是解决某个实际问题的计算步骤，研究如何让这个计算步骤以最小的代价实现。而编程研究的是怎么用程序表达，阅读起来更方便、维护起来更简单，代码本身就像注释一样清楚。

   ​	这是 7 种元素中，最重要，也是最难的一门科学。其他 6 种元素（基础知识），工程师往往学到一定程度，够用就行，而编程的技艺则需要一直深入学习、不断探索。

7. **编译原理**

   ​	在没有学习这门课程前，想深入任何一门计算机语言的底层，都会有相当大的难度。编译原理讲述的是程序语言如何被实现、源代码又如何被编译成应用。比如你想了解 JVM、V8 等引擎；想了解 Go/C++ 的编译器，从编译原理学起是不错的选择。

   ​	当然，对于应用开发者而言，编译原理提供的最大价值，就是用元编程技术设计自己的领域专有语言，从语言层面降低研发成本、提高交付效率。长此以往，还会发现系统有一些额外的能力是你之前没有想到的。比如 C++ 之父看到有个年轻人用自己设计的 C++ 模板在编译阶段计算圆周率，这就是他万万没有想到的额外能力，这种能力被称为模板元编程。

# 模块一：互联网和传输层协议

## 01｜ 漫游互联网：什么是蜂窝移动网络？

### 网络的组成

​	用无数个节点构成一个个小型网络，再用小型网络组成中型网络，再组成大型网络，以此类推，最后组成完整的一个如星河般的世界。

#### 公司内网

![公司内网结构示例](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB5O5KAFGFAAAD-82hpYWc483-20220812095325244.png "公司内网结构示例")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">图 1：公司内网结构示例</center>

​	公司网络从**本地网络服务提供商 （Internet Service Provider）** 接入，然后内部再分成一个个子网。上图 1 中，你看到的线路，也被称作**通信链路（Communication Link）**，用于传输网络信号。你可以观察到，有的网络节点，同时接入了 2 条以上的链路，这个时候因为路径发生了分叉，数据传输到这些节点需要选择方向，因此我们在这些节点需要进行**交换（Switch）**。

![封包交换](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/CioPOWB5O7uAUZ7qAAB_rmbTigw120.png "封包交换")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">图 2：封包交换（Packet Switch）</center>

​	交换技术的本质，就是让**数据切换路径**。因为，网络中的数据是以分组或封包（Packet）的形式传输，因此这个技术也称作**封包交换技术（Packet Switch）**。

​	比如说，你要传递一首 2Mb 的 MP3 的歌曲，歌曲本身不是一次传输完成的，而是被拆分成很多个封包。每个封包只有歌曲中的一部分数据，而封包一旦遇到岔路口，就需要封包交换技术帮助每个封包选择最合理的路径。

​	在网络中，常见的具有交换能力的设备是**路由器（Router）和链路层交换机（Link-Layer Switch）**。通常情况下，两个网络可以通过路由器进行连接，多台设备可以通过交换机进行连接。**但是路由器通常也具有交换机的功能**。

​	在上图 1 中，公司内部网络也被分成了多级子网。每个路由器、交换机构成一级子网。最高级的路由器在公司网络的边缘，它可以将网络内部节点连接到其他的网络（网络外部）。本地网络提供商（ISP）提供的互联网先到达边缘的路由器，然后再渗透到内部的网络节点。公司内部的若干服务器可以通过交换机形成一个局域网络；公司内部的办公设备，比如电脑和笔记本，也可以通过无线路由器或者交换机形成局域网络。**局域网络之间，可以通过路由器、交换机进行连接，从而构成一个更大的局域网**。

#### 移动网络

​	前面我们提到，网络传输需要通信链路（Communication Link），而通信链路是一个抽象概念。这里说的抽象，就是面向对象中抽象类和继承类的关系，比如同轴电缆是通信链路，无线信号的发送接收器可以构成通信链路，蓝牙信道也可以构成通信链路。

​	在移动网络中，无线信号构成了通信链路。在移动网络的设计中，通信的核心被称作**蜂窝塔（Cellular Tower）**，有时候也称作**基站（BaseStation）**。之所以有这样的名称，是因为每个蜂窝塔只覆盖一个六边形的范围，如果要覆盖一个很大的区域就需要很多的蜂窝塔（六边形）排列在一起，像极了蜜蜂的巢穴。这种六边形的结构，可以让信号无死角地覆盖。想象一下，如果是圆形结构，那么圆和圆之间就会有间隙，造成一部分无法覆盖的信号死角，而六边形就完美地解决了这个问题。![蜂巢网络示意图](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB5O86APsowAACbWDSSmH4919.png "蜂巢网络示意图")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">图三蜂巢网络示意图</center>

对于构成移动网络最小的网络结构——蜂窝网络来说，构造大体如图 4 所示：

![蜂窝移动网络构成](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/CioPOWB5O9qATnBsAACZHrgoKJM926.png "蜂窝移动网络构成")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">图 4：蜂窝移动网络构成</center>

​	图 4 中，国家或全球网络提供商将网络供给处于蜂窝网络边缘的路由器，路由器连接蜂窝塔，再通过蜂窝塔（基站）提供给处于六边形地区中的设备。通常是国家级别的网络服务提供商负责部署基站，比如中国电信、中国联通。将网络提供给一个子网的行为，通常称为**网络提供（Network Provider）**，反过来，对一个子网连接提供商的网络，称为**网络接入（Network Access）**。

​	随着移动网络的发展，一个蜂窝网格中的设备越来越多，也出现了基站覆盖有重叠关系的网格，如下图 5 所示：

![基站重叠的网格和边缘计算节点](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/CioPOWB5O-iAar0QAABo9zrq_yU298.png "基站重叠的网格和边缘计算节点")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">图 5 ：基站重叠的网格和边缘计算节点</center>

​	这样设计的好处是，当一个基站过载、出现故障，或者用户设备周边信号出现不稳定，就可以切换到另一个基站的网络，不影响用户继续使用网络服务。

​	另一方面，在一定范围内的区域，离用户较近的地方还可以部署服务器，帮助用户完成计算。这相当于计算资源的下沉，称为边缘计算。相比中心化的计算，边缘计算延迟低、链路短，能够将更好的体验带给距离边缘计算集群最近的节点。从而让用户享受到更优质、延迟更低、算力更强的服务。

![边缘计算](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/CioPOWB5O_mAPASCAACEaOOPkv0403.png "边缘计算")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">图 6：边缘计算</center>

#### 家用网络

​	还有一个值得讨论的是家用网络。近些年，家用联网设备越来越多。比如说冰箱、空调、扫地机器人、灯光、电动窗帘……![家用网络结构](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB5PAaAI4_7AADtVLTTA4U030.png "家用网络结构")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">图 7： 家用网络结构</center>

​	如上图 7 所示，家用网络现在已经发展成一种网格状的连接。一方面家用网络会通过路由器接入本地 ISP 提供的网络服务。另一方面，一些设备，比如电脑、笔记本、手机、冰箱等都可以直接和路由器连接。**路由器也承担了链路层网关的作用，作为家用电器之间信息的交换设备**。

​	还有一些家用设备，比如说 10 多块钱的灯泡，不太适合内部再嵌入一个几十块钱可以接收 WI-FI 的芯片，这个时候就可以考虑用蓝牙控制电灯。路由器提供蓝牙不现实，因此一些家用电器也承担了蓝牙设备的控制器——比如说智能音箱。上图 7 中的智能音箱把家用网络带向了一个网格状，有的设备会同时连接路由器（WI-FI）和智能音箱，这样手机和音箱都可以直接控制这些设备。这样的设计，即便网络断开，仍然可以控制这些家用设备。

#### 整体关系

以上，我们了解了 3 种常见的网络：公司网络、移动网络和家用网络。它们的整体关系如下图 8 所示：![互联网整体结构](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/CioPOWB5PBSAHzzqAAG9lxafSkI945.png "互联网整体结构")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">图 8：互联网整体结构</center>

​	最顶部的全球或国家大型的 ISP 之间联网，构成了网络的主干。然后区域性的 ISP 承接主干网络，在这个基础之上再向家庭和公司提供接入服务。移动蜂窝网络因为部署复杂，往往也是由大型 ISP 直接提供。

### 数据的传输

​	上述的网络结构中，由庞大数目的个人、公司、组织、基站，形成一个个网络。在这些网络中，传递数据不是一件容易的事情。

​	为了传递数据，在网络中有几个特别重要的抽象。最终提供服务或者享受服务的设备，称为**终端（Terminal），或者端系统（End System）**，有时候简单称为**主机（Host）**。比如说：电脑、手机、冰箱、汽车等，我们都可以看作是一个主机（Host）。

​	然后，我们可以把网络传输分成两类，一类是端到端（Host-to-Host）的能力，由 TCP/IP 协议群提供。还有一类是广播的能力，是一对多、多对多的能力，可以看作是端到端（Host-to-Host）能力的延伸。

​	你可以思考一下，一个北京的主机（Host）向一个深圳的主机（Host）发送消息。那么，中间会穿越大量的网络节点，这些节点可以是路由器、交换机、基站等。在发送消息的过程中，可能跨越很多网络、通过很多边缘，也可能会通过不同的网络提供商提供的网络……而且，传输过程中，可能会使用不同材质的通信链路（Communication Link），比如同轴电缆、双绞线、光纤，或者通过无线传输的 WI-FI、卫星等。

​	网络基础设施往往不能一次性传输太大的数据量，因此通常会将数据分片传输。比如传输一个 MP3，我们会将 MP3 内容切分成很多个组，每个组也称作一个封包，英文都是 Packet。这样，如果一个封包损坏，只需要重发损坏的封包，而不需要重发所有数据。你可以类比下中文的活字印刷技术。

​	另一方面，网络中两点间的路径非常多，如果一条路径阻塞了，部分封包可以考虑走其他路径。发送端将数据拆分成封包（Packet），封包在网络中遇到岔路，由交换器和路由器节点决定走向，图 9 中是对封包交换技术的一个演示。

![封包交换技术](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB5WbqAVlGaAHeNbdcL7hg030.gif"封包交换技术") 

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">图 9：封包交换技术</center>

### 总结

​	互联网是一个非常庞大的结构，从整体来看，互联网是一个立体的、庞大的网状结构。但是如果将它放大、再放大，将镜头拉近，在微观层面，我们会看到一个个网络、一台台设备，还会看到大量的封包在交换、有设备在不断地改变封包的走向、损坏的封包被重发、一个个光电信号被转化和传输。

​	这个过程看似复杂，但任何一个局部的设计都在井然有序地运行着。每次我想要深入研究互联网的设计时，都不禁再次感叹它的浩瀚——如今你看到的网络，是经过几个时代的发展沉淀下来的“宝藏”。不是某个人、某个团队就可以设计出来。所以从这个角度，我们可以把计算机网络看作是优秀的分层设计、精密的模块组装、准确的数值运算等一系列设计思想、工程方法的集合。如果你想学习软件架构，互联网就是一个最好的参照。

## 02 | 传输层协议 TCP：TCP 为什么握手是 3 次、挥手是 4 次？

​	TCP 和 UDP 是今天应用最广泛的传输层协议，拥有最核心的垄断地位。今天互联网的整个传输层，几乎都是基于这两个协议打造的。

无论是应用开发、框架设计选型、做底层和优化，还是定位线上问题，只要碰到网络，就逃不开 TCP 协议相关的知识。

一道高频面试题：TCP 协议为什么握手是 3 次，挥手却是 4 次？

### TCP 协议

​	**TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。**

​	这里面牵涉很多概念，比如主机到主机、连接、会话、双工/单工及可靠性等。

#### 主机到主机（Host-To-Host）

​	TCP 提供的是 Host-To-Host 传输，一台主机通过 TCP 发送数据给另一台主机。这里的主机（Host）是一个抽象的概念，可以是手机、

平板、手表等。收发数据的设备都是主机，所以双方是平等的。

![TCP/IP五层模型](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB5RAmAZRwzAACtAP-CPWs242.png "TCP/IP五层模型")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">TCP/IP五层模型</center>

​	**TCP 协议往上是应用到应用（Application-To-Application）的协议**。什么是应用到应用的协议呢？比如你用微信发信息给张三，你

的微信客户端、微信聊天服务都是应用。微信有自己的聊天协议，微信的聊天协议是应用到应用的协议；如果微信的聊天协议想要工作，

就需要一个主机到主机的协议帮助它实现通信。

​	而 TCP 上层有太多的应用，不仅仅有微信，还有原神、抖音、网易云音乐……因此 TCP 上层的应用层协议使用 TCP 能力的时候，需要

告知 TCP 是哪个应用——这就是**端口号。端口号用于区分应用**，下文中我们还会详细讨论。

​	TCP 要实现主机到主机通信，就需要知道主机们的**网络地址（IP 地址）**，但是 TCP 不负责实际地址到地址（Address-To-Address）的

传输，因此 TCP 协议把 IP 地址给底层的互联网层处理。

​	**互联网层，也叫网络层（Network Layer）**，**提供地址到地址的通信，**IP 协议就在这一层工作。互联网层解决地址到地址的通信，但

是不负责信号在具体两个设备间传递。因此，网络层会调用下方的链路层在两个相邻设备间传递信息。当信号在两个设备间传递的时候，

科学家又设计出了物理层封装最底层的物理设备、传输介质等，由最下方的物理层提供最底层的传输能力。

​	以上的 5 层架构，我们称为互联网协议群，也称作 TCP/IP 协议群。总结下，主机到主机（Host-To-Host）为应用提供应用间通信的能力。

#### 什么是连接和会话？

​	下一个关联的概念是**连接（Connection）**——**连接是数据传输双方的契约**。

​	连接是通信双方的一个约定，目标是让两个在通信的程序之间产生一个默契，保证两个程序都在线，而且尽快地响应对方的请求，这就是**连接（Connection）**。

​	设计上，连接是一种传输数据的行为。传输之前，建立一个连接。具体来说，数据收发双方的内存中都建立一个用于维护数据传输状态

的对象，比如双方 IP 和端口是多少？现在发送了多少数据了？状态健康吗？传输速度如何？等。所以，**连接是网络行为状态的记录**。

​	和连接关联的还有一个名词，叫作**会话（Session），会话是应用的行为**。比如微信里张三和你聊天，那么张三和你建立一个会话。你

要和张三聊天，你们创建一个聊天窗口，这个就是会话。你开始 Typing，开始传输数据，你和微信服务器间建立一个连接。如果你们聊

一段时间，各自休息了，约定先不要关微信，1 个小时后再回来。那么连接会断开，因为聊天窗口没关，所以会话还在。

​	在有些系统设计中，会话会自动重连（也就是重新创建连接），或者帮助创建连接。 此外，会话也负责在多次连接中保存状态，比如 

HTTP Session 在多次 HTTP 请求（连接）间保持状态（如用户信息）。

**总结下，会话是应用层的概念，连接是传输层的概念。**

#### 双工/单工问题

- 在任何一个时刻，如果数据只能单向发送，就是单工，所以单工需要至少一条线路。

- 如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。
- 如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。当然这里的线路，是一个抽象概念，你可以并发地处理信号，达到模拟双工的目的。

​	TCP 是一个双工协议，数据任何时候都可以双向传输。这就意味着客户端和服务端可以平等地发送、接收信息。正因为如此，客户端和

服务端在 TCP 协议中有一个平等的名词——Host（主机）。

#### 什么是可靠性？

上文提到 TCP 提供可靠性，那么可靠性是什么？

​	**可靠性指数据保证无损传输**。如果发送方按照顺序发送，然后数据无序地在网络间传递，就必须有一种算法在接收方将数据恢复原有的

顺序。另外，如果发送方同时要把消息发送给多个接收方，这种情况叫作多播，可靠性要求每个接收方都无损收到相同的副本。多播情况

还有强可靠性，就是如果有一个消息到达任何一个接收者，那么所有接受者都必须收到这个消息。说明一下，本专栏中，我们都是基于单

播讨论可靠性。

#### TCP 的握手和挥手

​	TCP 是一个连接导向的协议，设计有建立连接（握手）和断开连接（挥手）的过程。TCP 没有设计会话（Session），因为会话通常是

一个应用的行为。

#### TCP 协议的基本操作

TCP 协议有这样几个基本操作：

- 如果一个 Host 主动向另一个 Host 发起连接，称为 SYN（Synchronization），请求同步；

- 如果一个 Host 主动断开请求，称为 FIN（Finish），请求完成；

- 如果一个 Host 给另一个 Host 发送数据，称为 PSH（Push），数据推送。

​	以上 3 种情况，接收方收到数据后，都需要给发送方一个 ACK（Acknowledgement）响应。请求/响应的模型是可靠性的要求，如果

一个请求没有响应，发送方可能会认为自己需要重发这个请求。

#### 建立连接的过程（三次握手）

​	因为要保持连接和可靠性约束，TCP 协议要保证每一条发出的数据必须给返回，返回数据叫作 ACK（也就是响应）。

​	按照这个思路，你可以看看建立连接是不是需要 3 次握手：

![tcp三次握手](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/CioPOWB-RYSASfPkAAEen4ZR3gw297.png"tcp三次握手")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">TCP三次握手</center>

1. 客户端发消息给服务端（SYN）
2. 服务端准备好进行连接
3. 服务端针对客户端的 SYN 给一个 ACK

​	你可以能会问，到这里不就可以了吗？2 次握手就足够了。但其实不是，因为服务端还没有确定客户端是否准备好了。比如步骤 3 之

后，服务端马上给客户端发送数据，这个时候客户端可能还没有准备好接收数据。因此还需要增加一个过程。

接下来还会发生以下操作：

4. 服务端发送一个 SYN 给客户端

5. 客户端准备就绪

6. 客户端给服务端发送一个 ACK

上面不是 6 个步骤吗？ 怎么是 3 次握手呢？下面我们一起分析一下其中缘由。

- 步骤 1 是 1 次握手；

+ 步骤 2 是服务端的准备，不是数据传输，因此不算握手；

- 步骤 3 和步骤 4，因为是同时发生的，可以合并成一个 SYN-ACK 响应，作为一条数据传递给客户端，因此是第 2 次握手；

- 步骤 5 不算握手；

- 步骤 6 是第 3 次握手。

​	为了方便你理解步骤 3 和步骤 4，这里我画了一张图。可以看到下图中 SYN 和 ACK 被合并了，因此建立连接一共需要 3 次握手，过程如下图所示：

![TCP三次连接简化图](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB5RCqAVfhiAADJmfGn2O0616.png "TCP三次连接简化图")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">TCP三次连接简化图</center>

从上面的例子中，你可以进一步思考 SYN、ACK、PSH 这些常见的标识位（Flag）在传输中如何表示。

​	一种思路是为 TCP 协议增加协议头。在协议头中取多个位（bit），其中 SYN、ACK、PSH 都占有 1 个位。比如 SYN 位，1 表示 SYN 开启，0 表示关闭。因此，SYN-ACK 就是 SYN 位和 ACK 位都置 1。这种设计，我们也称为标识（Flag）。标识位是放在 TCP 头部的，关于标识位和 TCP 头的内容，我会在“04 | TCP 的稳定性：滑动窗口和流速控制是怎么回事？”中详细介绍。

#### 断开连接的过程（4 次挥手）

继续上面的思路，如果断开连接需要几次握手？给你一些提示，你可以在脑海中这样构思。

1. 客户端要求断开连接，发送一个断开的请求，这个叫作（FIN）。

2. 服务端收到请求，然后给客户端一个 ACK，作为 FIN 的响应。

3. 这里你需要思考一个问题，可不可以像握手那样马上传 FIN 回去？
   其实这个时候服务端不能马上传 FIN，因为断开连接要处理的问题比较多，比如说服务端可能还有发送出去的消息没有得到 ACK；也有可能服务端自己有资源要释放。因此断开连接不能像握手那样操作——将两条消息合并。所以，服务端经过一个等待，确定可以关闭连接了，再发一条 FIN 给客户端。

4. 客户端收到服务端的 FIN，同时客户端也可能有自己的事情需要处理完，比如客户端有发送给服务端没有收到 ACK 的请求，客户端自己处理完成后，再给服务端发送一个 ACK。

经过以上分析，就可以回答上面这个问题了。是不是刚刚好 4 次挥手？过程如下图所示：

![TCP四次握手](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/CioPOWCTwu-AD9PgAABp1yJqsPI439.png "TCP四次握手")

<center style="font-size:14px; color: #CoCoCo; text-decoration: underline">TCP四次握手</center>

### 总结

1. TCP 提供连接（Connection），让双方的传输更加稳定、安全。

2. TCP 没有直接提供会话，因为应用对会话的需求多种多样，比如聊天程序会话在保持双方的聊天记录，电商程序会话在保持购物车、订单一致，所以会话通常在 TCP 连接上进一步封装，在应用层提供。

3. TCP 是一个面向连接的协议（Connection -oriented Protocol），说的就是 TCP 协议参与的双方（Host）在收发数据之前会先建立连接。后面我们还会学习 UDP 协议，UDP 是一个面向报文（Datagram-oriented）的协议——协议双方不需要建立连接，直接传送报文（数据）。

4. 最后，连接需要消耗更多的资源。比如说，在传输数据前，必须先协商建立连接。因此，不是每种场景都应该用连接导向的协议。像视频播放的场景，如果使用连接导向的协议，服务端每向客户端推送一帧视频，客户端都要给服务端一次响应，这是不合理的。

那么通过这一讲的学习，你现在可以尝试来回答本讲关联的面试题目：TCP 为什么是 3 次握手，4 次挥手？

【解析】TCP 是一个双工协议，为了让双方都保证，建立连接的时候，连接双方都需要向对方发送 SYC（同步请求）和 ACK（响应）。

​	握手阶段双方都没有烦琐的工作，因此一方向另一方发起同步（SYN）之后，另一方可以将自己的 ACK 和 SYN 打包作为一条消息回复，因此是 3 次握手——需要 3 次数据传输。

​	到了挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应（ACK），表示接收到了挥手请求。类比现实世界

中，你收到一个 Offer，出于礼貌你先回复考虑一下，然后思考一段时间再回复 HR 最后的结果。最后等所有工作结束，再发送请求中断

连接（FIN），因此是 4 次挥手。

### 思考题

一台内存在 8G 左右的服务器，可以同时维护多少个连接？

## 03 | TCP 的封包格式：TCP 为什么要粘包和拆包？

​	今天我们将从稳定性角度深挖 TCP 协议的运作机制。如今，大半个互联网都建立在 TCP 协议之上，我们使用的 HTTP 协议、消息队

列、存储、缓存，都需要用到 TCP 协议——这是因为 TCP 协议提供了可靠性。简单来说，可靠性就是让数据无损送达。但若是考虑到成

本，就会变得非常复杂——因为还需要尽可能地提升吞吐量、降低延迟、减少丢包率。

​	TCP 协议具有很强的实用性，而可靠性又是 TCP 最核心的能力，所以理所当然成为面试官们津津乐道的问题。具体来说，从一个终端

有序地发出多个数据包，经过一个复杂的网络环境，到达目的地的时候会变得无序，而可靠性要求数据恢复到原始的顺序。这里我先给你

提出两个问题：

- TCP 协议是如何恢复数据的顺序的？

- 拆包和粘包的作用是什么？

下面请你带着这两个问题开始今天的学习。

### TCP 的拆包和粘包

​	TCP 是一个传输层协议。TCP 发送数据的时候，往往不会将数据一次性发送，像下图这样：

![Cgp9HWB-mySAMiRJAACvL4JE7Ow394](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB-mySAMiRJAACvL4JE7Ow394.png)

​	而是将数据拆分成很多个部分，然后再逐个发送。像下图这样：

![CioPOWB-myyARws0AADwpYVdoRk460](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/CioPOWB-myyARws0AADwpYVdoRk460.png)

​	同样的，在目的地，TCP 协议又需要逐个接收数据。**TCP 为什么不一次发送完所有的数据？**比如我们要传一个大小为 10M 

的文件，对于应用层而言，就是一次传送完成的。而传输层的协议为什么不选择将这个文件一次发送完呢？

​	这里有很多原因，比如为了稳定性，一次发送的数据越多，出错的概率越大。再比如说为了效率，网络中有时候存在着并行的路径，拆

分数据包就能更好地利用这些并行的路径。再有，比如发送和接收数据的时候，都存在着缓冲区。如下图所示：

![Cgp9HWB-mz2ALAO6AAFJNuQ9-SU088](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB-mz2ALAO6AAFJNuQ9-SU088.png)

​	缓冲区是在内存中开辟的一块区域，目的是缓冲。因为大量的应用频繁地通过网卡收发数据，这个时候，网卡只能一个一个处理应用的

请求。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。如果每个应用都随意发送很大的数据，可能导致其他应用实

时性遭到破坏。

​	还有一些原因我们在《重学操作系统》专栏的“24 | 虚拟内存 ：一个程序最多能使用多少内存？”中讨论过。比如内存的最小分配单位是

页表，如果数据的大小超过一个页表，可能会存在页面置换问题，造成性能的损失。

​	总之，方方面面的原因：**在传输层封包不能太大**。这种限制，往往是以缓冲区大小为单位的。也就是 TCP 协议，会将数据拆分成不超

过缓冲区大小的一个个部分。每个部分有一个独特的名词，叫作 **TCP 段（TCP Segment）**。

​	在接收数据的时候，一个个 TCP 段又被重组成原来的数据。

​	像这样，数据经过拆分，然后传输，然后在目的地重组，俗称**拆包**。所以拆包是将数据拆分成多个 TCP 段传输。那么粘包是什么呢？

​	有时候，如果发往一个目的地的多个数据太小了，为了防止多次发送占用资源，TCP 协议有可能将它们合并成一个 TCP 段发送，在目

的地再还原成多个数据，这个过程俗称**粘包**。所以粘包是将多个数据合并成一个 TCP 段发送。

### TCP Segment

那么一个 TCP 段长什么样子呢？下图是一个 TCP 段的格式：

![Cgp9HWB-m0mARV-VAAZgGUE4aeU706](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB-m0mARV-VAAZgGUE4aeU706.png)

我们可以看到，TCP 的很多配置选项和数据粘在了一起，作为一个 TCP 段。

​	TCP 协议就是依靠每一个 TCP 段工作的，所以你每认识一个 TCP 的能力，几乎都会找到在 TCP Segment 中与之对应的字段。

1. Source Port/Destination Port 描述的是发送端口号和目标端口号，代表发送数据的应用程序和接收数据的应用程序。比如 80 往往代表 HTTP 服务，22 往往是 SSH 服务……

2. Sequence Number 和 Achnowledgment Number 是保证可靠性的两个关键。具体见下文的讨论。

3. Data Offset 是一个偏移量。这个量存在的原因是 TCP Header 部分的长度是可变的，因此需要一个数值来描述数据从哪个字节开始。

4. Reserved 是很多协议设计会保留的一个区域，用于日后扩展能力。

5. URG/ACK/PSH/RST/SYN/FIN 是几个标志位，用于描述 TCP 段的行为。也就是一个 TCP 封包到底是做什么用的？

   1）URG 代表这是一个紧急数据，比如远程操作的时候，用户按下了 Ctrl+C，要求终止程序，这种请求需要紧急处理。

   2）ACK 代表响应，我们在“02 | 传输层协议 TCP：TCP 为什么握手是 3 次、挥手是 4 次？”讲到过，所有的消息都必须有 ACK，这是 TCP 协议确保稳定性的一环。

   3）PSH 代表数据推送，也就是在传输数据的意思。

   4）SYN 同步请求，也就是申请握手。

   5）FIN 终止请求，也就是挥手。

**特别说明一下：以上这 5 个标志位，每个占了一个比特，可以混合使用。比如 ACK 和 SYN 同时为 1，代表同步请求和响应被合并了。这也是 TCP 协议，为什么是三次握手的原因之一。**

6. Window 也是 TCP 保证稳定性并进行流量控制的工具，我们会在“04 | TCP 的稳定性：滑动窗口和流速控制是怎么回事？”中详细介绍。
7. Checksum 是校验和，用于校验 TCP 段有没有损坏。
8. Urgent Pointer 指向最后一个紧急数据的序号（Sequence Number）。它存在的原因是：有时候紧急数据是连续的很多个段，所以需要提前告诉接收方进行准备。
9. Options 中存储了一些可选字段，比如接下来我们要讨论的 MSS（Maximun Segment Size）。
10. Padding 存在的意义是因为 Options 的长度不固定，需要 Pading 进行对齐。

### Sequence Number 和 Acknowledgement Number

​	在 TCP 协议的设计当中，数据被拆分成很多个部分，部分增加了协议头。合并成为一个 TCP 段，进行传输。这个过程，我们俗称拆

包。这些 TCP 段经过复杂的网络结构，由底层的 IP 协议，负责传输到目的地，然后再进行重组。

​	这里请你思考一个问题：稳定性要求数据无损地传输，也就是说拆包获得数据，又需要恢复到原来的样子。而在复杂的网络环境当中，

即便所有的段是顺序发出的，也不能保证它们顺序到达，因此，发出的每一个 TCP 段都需要有序号。这个序号，就是 Sequence 

Number（Seq）。

![Cgp9HWB-m4CAaJ61AADgfscwtY8443](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB-m4CAaJ61AADgfscwtY8443.png)

​	如上图所示。发送数据的时候，为每一个 TCP 段分配一个自增的 Sequence Number。接收数据的时候，虽然得到的是乱序的 TCP 

段，但是可以通过 Seq 进行排序。

​	但是这样又会产生一个新的问题——接收方如果要回复发送方，也需要这个 Seq。而网络的两个终端，去同步一个自增的序号是非常困

难的。因为任何两个网络主体间，时间都不能做到完全同步，又没有公共的存储空间，无法共享数据，更别说实现一个分布式的自增序号

了。

​	其实这个问题的本质就好像两个人在说话一样，我们要确保他们说出去的话，和回答之间的顺序。因为 TCP 是一个双工的协议，两边

可能会同时说话。所以聪明的科学家想到了确定一句话的顺序，需要两个值去描述——也就是发送的字节数和接收的字节数。

![CioPOWB-m8WAN4r7AAG-F3w2k2k929](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/CioPOWB-m8WAN4r7AAG-F3w2k2k929.png)

​	我们重新定义一下 Seq（如上图所示），对于任何一个接收方，如果知道了发送者发送某个 TCP 段时，已经发送了多少字节的数据，

那么就可以确定发送者发送数据的顺序。

​	但是这里有一个问题。如果接收方也向发送者发送了数据请求（或者说双方在对话），接收方就不知道发送者发送的数据到底对应哪一

条自己发送的数据了。

举个例子：下面 A 和 B 的对话中，我们可以确定他们彼此之间接收数据的顺序。但是无法确定数据之间的关联关系，所以只有 Sequence Number 是不够的。

```
A：今天天气好吗？
A：今天你开心吗？
B：开心
B：天气不好
```

​	人类很容易理解这几句话的顺序，但是对于机器来说就需要特别的标注。因此我们还需要另一个数据，就是每个 TCP 段发送时，发送

方已经接收了多少数据。用 Acknowledgement Number 表示，下面简写为 ACK。

下图中，终端发送了三条数据，并且接收到四条数据，通过观察，根据接收到的数据中的 Seq 和 ACK，将发送和接收的数据进行排序。

![Cgp9HWB-m82AUJiLAAHfbaP08JE788](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB-m82AUJiLAAHfbaP08JE788.png)

​	例如上图中，发送方发送了 100 字节的数据，而接收到的（Seq = 0 和 Seq =100）的两个封包，都是针对发送方（Seq = 0）这个封包

的。发送 100 个字节，所以接收到的 ACK 刚好是 100。说明（Seq= 0 和 Seq= 100）这两个封包是针对接收到第 100 个字节数据后，发

送回来的。这样就确定了整体的顺序。

注意，无论 Seq 还是 ACK，都是针对“对方”而言的。是对方发送的数据和对方接收到的数据。我们在实际的工作当中，可以通过 Whireshark 调试工具观察两个 TCP 连接的 Seq和 ACK。

具体的使用方法，我会在“09 | TCP 实战：如何进行 TCP 抓包调试？"中和你讨论。

![Cgp9HWB-m9WAO8jwAAUDwhNzXjU379](https://raw.githubusercontent.com/Bug-Kepler/typoraImg/main/img/Cgp9HWB-m9WAO8jwAAUDwhNzXjU379.png)

### MSS（Maximun Segment Size）

​	接下来，我们讨论下 MSS，它也是面试经常会问到的一个 TCP Header 中的可选项（Options），这个可选项控制了 TCP 段的大小，

它是一个协商字段（Negotiate）。协议是双方都要遵循的标准，因此配置往往不能由单方决定，需要双方协商。

​	TCP 段的大小（MSS）涉及发送、接收缓冲区的大小设置，双方实际发送接收封包的大小，对拆包和粘包的过程有指导作用，因此需要

双方去协商。

如果这个字段设置得非常大，就会带来一些影响。

​	首先对方可能会拒绝，作为服务的提供方，你可能不会愿意接收太大的 TCP 段。因为大的 TCP 段，会降低性能，比如内存使用的性

能。具体你可以参考《重学操作系统》课程中关于页表的讨论。

- 24 | 虚拟内存 ：一个程序最多能使用多少内存？

- 25 | 内存管理单元： 什么情况下使用大内存分页？

- 26 | 缓存置换算法： LRU 用什么数据结构实现更合理？

​	还有就是资源的占用。一个用户占用服务器太多的资源，意味着其他的用户就需要等待或者降低他们的服务质量。

​	**其次，支持 TCP 协议工作的 IP 协议，工作效率会下降。**TCP 协议不肯拆包，IP 协议就需要拆出大量的包。那么 IP 协议为什么需要拆

包呢？这是因为在网络中，每次能够传输的数据不可能太大，这受限于具体的网络传输设备，也就是物理特性。但是 IP 协议，拆分太多

的封包并没有意义。因为可能会导致属于同个 TCP 段的封包被不同的网络路线传输，这会加大延迟。同时，拆包，还需要消耗硬件和计

算资源。

​	那是不是 MSS 越小越好呢？MSS 太小的情况下，会浪费传输资源（降低吞吐量）。因为数据被拆分之后，每一份数据都要增加一个头

部。如果 MSS 太小，那头部的数据占比会上升，这让吞吐量成为一个灾难。**所以在使用的过程当中，MSS 的配置，往往都是一个折中的**

**方案。**而根据 Unix 的哲学，不要去猜想什么样的方案是最合理的，而是要尝试去用实验证明它，一切都要用实验依据说话。

### 总结

​	TCP 协议的设计像一台巨大而严密的机器，每次我重新温习 TCP 协议，都会感叹“它庞大，而且很琐碎”。每一个细节的设计，都有很深

的思考。比如 Sequence Number 和 Acknowledge Number 的设计，就非常巧妙地利用发送字节数和接收字节数解决了顺序的问题。

TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么？

【解析】TCP 拆包的作用是将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力。拆包过程需要保证数据经过网络

的传输，又能恢复到原始的顺序。这中间，需要数学提供保证顺序的理论依据。TCP 利用（发送字节数、接收字节数）的唯一性来确定封

包之间的顺序关系。具体的算法，我们会在下一讲“04 | TCP 的稳定性解决方案 ：滑动窗口和流量控制是怎么回事？”中给出。粘包是为了

防止数据量过小，导致大量的传输，而将多个 TCP 段合并成一个发送。

### 思考题

有哪些好用的压测工具？
